<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Relic Loadout Editor</title>
    <style>
        :root {
            /* Theme matching index.html (GitHub Dark Dimmed style) */
            --bg-color: #0d1117;
            --panel-bg: #161b22;
            --border-color: #30363d;
            --text-color: #c9d1d9;
            --text-muted: #8b949e;
            --accent-color: #58a6ff;
            --input-bg: #0d1117;
            
            --grid-cell-size: 60px;
            --slot-bg: #21262d;
            --slot-blocked: #010409;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            line-height: 1.5;
        }

        /* Layout */
        .header {
            padding: 15px 20px;
            background-color: var(--panel-bg);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .header h3 {
            margin: 0;
            color: var(--accent-color);
            font-size: 1.2rem;
        }

        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
            gap: 0;
        }

        .stash-panel {
            width: fit-content;
            min-width: 260px;
            flex: 0 0 auto;
            background-color: var(--panel-bg);
            border-right: 1px solid var(--border-color);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 5;
            overflow-y: auto;
        }

        .stash-grid {
            display: grid;
            /* Use the NEW variable here */
            grid-template-columns: repeat(4, var(--stash-cell-size));
            grid-auto-rows: var(--stash-cell-size);
            /* ... rest remains same ... */
            gap: 4px;
            background-color: var(--bg-color);
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            min-height: 400px;
            align-content: start;
            position: relative;
        }

        .sidebar {
            width: 200px;
            background-color: var(--panel-bg);
            border-right: 1px solid var(--border-color);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow-y: auto;
        }

        .editor-area {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #010409; /* Darker background for canvas */
            position: relative;
            overflow: auto;
            background-image: radial-gradient(#21262d 1px, transparent 1px);
            background-size: 20px 20px;
        }

        .properties-panel {
            width: 420px;
            background-color: var(--panel-bg);
            border-left: 1px solid var(--border-color);
            padding: 20px;
            overflow-y: auto;
        }

        h4 {
            margin-top: 0;
            margin-bottom: 12px;
            color: var(--text-color);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 8px;
        }

        hr {
            border: 0;
            border-top: 1px solid var(--border-color);
            margin: 15px 0;
        }

        /* Inputs & Status */
        input[type="file"] {
            display: none;
        }

        .file-upload-btn {
            background-color: var(--bg-color);
            border: 1px solid var(--border-color);
            color: var(--accent-color);
            padding: 8px;
            cursor: pointer;
            font-size: 0.9em;
            text-align: center;
            display: block;
            border-radius: 6px;
            transition: 0.2s;
        }
        
        .file-upload-btn:hover {
            border-color: var(--accent-color);
        }
        
        .file-upload-btn.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            color: var(--text-muted);
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            font-size: 0.85em;
            padding: 6px 0;
            border-bottom: 1px solid var(--border-color);
            color: var(--text-muted);
        }

        .status-pending { color: #d29922; } /* GitHub Warning Color */
        .status-ok { color: #3fb950; }     /* GitHub Success Color */
        .status-error { color: #f85149; }  /* GitHub Error Color */

        /* Grid Visualization */
        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(7, var(--grid-cell-size));
            grid-template-rows: repeat(6, var(--grid-cell-size));
            gap: 4px;
            position: relative;
            background-color: var(--bg-color);
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .grid-slot {
            width: var(--grid-cell-size);
            height: var(--grid-cell-size);
            background-color: var(--slot-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }

        .grid-slot.blocked {
            background-color: var(--slot-blocked);
            border-color: #111;
            background-image: repeating-linear-gradient(45deg, var(--slot-blocked) 0, var(--slot-blocked) 10px, #161b22 10px, #161b22 20px);
        }

        .relic-item {
            position: absolute;
            background-color: rgba(22, 27, 34, 0.95);
            border: 2px solid var(--text-muted);
            box-sizing: border-box;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.75em;
            text-align: center;
            transition: all 0.2s;
            overflow: hidden;
            z-index: 10;
            padding: 2px;
            word-break: break-word;
            border-radius: 4px;
            color: var(--text-color);
        }

        .relic-item:hover {
            border-color: var(--text-color);
            z-index: 20;
            transform: translateY(-2px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.5);
        }

        .relic-item.selected {
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px rgba(88, 166, 255, 0.4);
            z-index: 30;
        }

        /* Rarity Colors (Adjusted for Dark Mode) */
        .rarity-0 { border-color: #8b949e; background: #21262d; } 
        .rarity-1 { border-color: #58a6ff; background: #0d1117; } 
        .rarity-2 { border-color: #d29922; background: #251e08; } 
        .rarity-3 { border-color: #f85149; background: #280d0d; } 

        /* Form Elements */
        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 6px;
            font-size: 0.85em;
            color: var(--text-muted);
        }

        input[type="text"], input[type="number"], select {
            width: 100%;
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            padding: 6px 10px;
            box-sizing: border-box;
            border-radius: 6px;
        }

        input:focus, select:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 1px var(--accent-color);
        }

        /* Remove spinner arrows from number inputs */
        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { 
            -webkit-appearance: none; 
            margin: 0; 
        }

        input[type=number] {
            -moz-appearance: textfield; /* Firefox */
        }

        button {
            background-color: #238636; /* GitHub Green */
            color: white;
            border: 1px solid rgba(240,246,252,0.1);
            padding: 6px 16px;
            cursor: pointer;
            font-weight: 500;
            border-radius: 6px;
            transition: 0.2s;
        }

        button:hover { background-color: #2ea043; }
        button:disabled { background-color: #21262d; color: #8b949e; cursor: not-allowed; border-color: var(--border-color); }

        /* Affix Styling */
        .affix-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .affix-item {
            background: var(--bg-color);
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            position: relative;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type=range] {
            flex: 1;
            accent-color: var(--accent-color);
            background: transparent;
            cursor: pointer;
        }

        .calculated-value {
            font-size: 0.9em;
            color: #3fb950; /* Green */
            font-weight: bold;
            margin-bottom: 5px;
            display: block;
        }

        .range-info {
            font-size: 0.75em;
            color: var(--text-muted);
            float: right;
            background: rgba(110, 118, 129, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
        }
        
        .multiplier-tag {
            background: rgba(56, 139, 253, 0.15);
            color: #58a6ff;
            padding: 1px 6px;
            border-radius: 10px;
            font-size: 0.75em;
            margin-left: 5px;
            border: 1px solid rgba(56, 139, 253, 0.4);
        }

        .btn-download {
            background-color: #238636;
        }

        .btn-add {
            background-color: #1f6feb; /* GitHub Blue for primary actions */
            width: 100%;
            margin-top: 10px;
            padding: 8px;
            font-size: 0.9em;
        }
        .btn-add:hover { background-color: #388bfd; }

        .btn-remove {
            background-color: transparent;
            color: #f85149;
            border: 1px solid rgba(248, 81, 73, 0.4);
            padding: 4px 10px;
            font-size: 0.8em;
            border-radius: 6px;
        }
        .btn-remove:hover { 
            background-color: rgba(248, 81, 73, 0.1);
            border-color: #f85149;
        }

        .affix-footer {
            display: flex;
            justify-content: flex-end;
            margin-top: 10px;
            padding-top: 8px;
            border-top: 1px solid var(--border-color);
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.75);
            backdrop-filter: blur(2px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            display: none;
        }

        .modal-content {
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            width: 500px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            padding: 24px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.5);
            border-radius: 8px;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-search {
            width: 100%;
            padding: 8px 12px;
            background: var(--input-bg);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            margin-bottom: 15px;
            border-radius: 6px;
            font-size: 1rem;
        }

        .affix-search-list {
            flex: 1;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            background: var(--bg-color);
            border-radius: 6px;
        }

        .search-item {
            padding: 10px 15px;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            transition: background 0.1s;
        }

        .search-item:last-child { border-bottom: none; }

        .search-item:hover {
            background: #21262d;
        }

        .search-item strong {
            display: block;
            color: var(--text-color);
        }

        .search-item small {
            color: var(--text-muted);
        }

        .btn-close {
            background: transparent;
            border: none;
            color: var(--text-muted);
            font-size: 1.5em;
            cursor: pointer;
            padding: 0;
        }
        .btn-close:hover { color: var(--text-color); }
        
        .btn-select-affix {
            background: var(--bg-color);
            color: var(--text-color);
            width: 100%;
            text-align: left;
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            transition: border-color 0.2s;
        }
        .btn-select-affix:hover {
            border-color: var(--accent-color);
        }

        .relic-item.dragging {
            opacity: 0.9;
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
            z-index: 100 !important;
            cursor: grabbing;
            transition: none; /* Disable transition for instant follow response */
            pointer-events: none; /* Important for mouse tracking */
        }

        /* Ensure the container catches mouse events when item has pointer-events: none */
        .inventory-grid {
            user-select: none; /* Prevent text selection while dragging */
        }

        .trash-zone {
            margin-top: auto; /* Push to bottom of stash panel */
            border: 2px solid #f85149; /* Red dashed border */
            color: #f85149;
            border-radius: 6px;
            padding: 30px;
            text-align: center;
            font-weight: bold;
            cursor: default;
            transition: all 0.2s;
            background-color: rgba(40, 13, 13, 0.70);
        }

        .trash-zone.drag-over {
            background-color: rgba(248, 81, 73, 0.2);
            transform: scale(1.02);
            box-shadow: 0 0 15px rgba(248, 81, 73, 0.3);
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar { width: 10px; height: 10px; }
        ::-webkit-scrollbar-track { background: var(--bg-color); border-left: 1px solid var(--border-color); }
        ::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 5px; border: 2px solid var(--bg-color); }
        ::-webkit-scrollbar-thumb:hover { background: #565e68; }
    </style>
</head>
<body>

<div class="header">
    <h3>Relic Loadout Editor</h3>
    <div style="flex:1"></div>
    <button onclick="app.downloadSave()" class="btn-download" id="downloadBtn" disabled>Download save file</button>
</div>

<div class="main-content">
    <div class="sidebar">
        <h4>Database Status</h4>
        <div class="status-item">
            <span>Relics DB</span> <span id="status-relics" class="status-pending">Loading...</span>
        </div>
        <div class="status-item">
            <span>Affixes DB</span> <span id="status-affixes" class="status-pending">Loading...</span>
        </div>
        <div class="status-item">
            <span>Config DB</span> <span id="status-config" class="status-pending">Loading...</span>
        </div>
        
        <h4>Save File</h4>
        <div class="form-group">
            <label class="file-upload-btn" id="lbl-save">
                Select File
                <input type="file" id="inp-save" onchange="app.loadSaveFile(this)" disabled>
            </label>
        </div>
        
        <h4>Loadout Selection</h4>
        <select id="loadoutSelect" onchange="app.switchLoadout()" disabled>
            <option>Load save file first...</option>
        </select>

        <div style="margin-top: 20px;">
            <label>Cell Size: <span id="cellSizeDisplay">80px</span></label>
            <input type="range" min="65" max="95" value="80" 
                   oninput="app.updateGridSettings(this.value)">
        </div>
    </div>

    <div class="stash-panel">
        <h4>Relic Stash (Not Saved)</h4>
        <p style="font-size:0.8em; color:#8b949e; margin-top:-10px;">
            Drag items here to store them. Items in stash are NOT exported.
        </p>
        <div id="stashContainer" class="stash-grid"></div>
        <div id="trashZone" class="trash-zone">
            Drop here to delete
        </div>
    </div>

    <div class="editor-area">
        <div id="gridContainer" class="inventory-grid"></div>
    </div>

    <div class="properties-panel">
        <h4>Inspector</h4>
        <div id="inspectorContent">
            <p style="color: #666; font-style: italic;">Select a relic to edit details.</p>
        </div>
    </div>
</div>

<div id="affixModal" class="modal-overlay">
    <div class="modal-content">
        <div class="modal-header">
            <h3>Select Affix</h3>
            <button class="btn-close" onclick="app.closeModal()">&times;</button>
        </div>
        <input type="text" id="affixSearchInput" class="modal-search" placeholder="Search affixes..." onkeyup="app.filterAffixes()">
        <div id="affixSearchResults" class="affix-search-list">
            </div>
    </div>
</div>

<script>
class RelicEditor {
    constructor() {
        this.data = {
            save: null,
            relics: null,
            affixes: null,
            config: null
        };
        
        this.definitions = {
            relics: {}, 
            affixes: {},
            // Loaded from file (Global Default)
            defaultUpgradeModifiers: null, 
            // Hardcoded Fallback (Standard Curve)
            fallbackUpgradeModifiers: {
                "0": 1.0, "1": 1.2, "2": 1.4, "3": 1.6, "4": 1.8,
                "5": 2.0, "6": 2.2, "7": 2.4, "8": 2.6, "9": 2.8, "10": 3.0
            },
            sizes: {
                "Small":   {w: 1, h: 1},
                "Large":   {w: 1, h: 2}, 
                "Grand":   {w: 1, h: 4},
                "Exalted": {w: 2, h: 2},
                "Default": {w: 1, h: 1}
            }
        };

        this.stashItems = []; // Items here are NOT in this.data.save
        this.stashWidth = 8;  // 4 slots wide
        this.stashHeight = 15; // Arbitrary height
        this.stashCellSize = 60;
        this.deletedItemHistory = [];

        document.addEventListener('keydown', (e) => {
        // Check for Ctrl+Z (or Cmd+Z on Mac)
        if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
            // Ignore if user is typing in an input field
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            
                e.preventDefault();
                this.undoLastDelete();
            }
        });

        this.currentLoadoutIndex = 0;
        this.selectedRelicIndex = -1;
        
        this.initAutoLoad();
    }

    async initAutoLoad() {
        const files = [
            { key: 'relics', path: 'json_data/relic_data/Relics.json' },
            { key: 'affixes', path: 'json_data/relic_data/Relic Affixes.json' },
            { key: 'config', path: 'json_data/relic_data/Relic Inventory Config.json' },
            { key: 'implicit_mapping', path: 'json_data/relic_data/implicit_mapping.json' }
        ];

        try {
            const promises = files.map(file => 
                fetch(file.path)
                    .then(response => {
                        if (!response.ok) throw new Error(`HTTP ${response.status}`);
                        return response.json();
                    })
                    .then(data => {
                        this.data[file.key] = data;
                        this.updateStatus(file.key, 'Loaded', 'ok');
                    })
                    .catch(err => {
                        console.error(`Failed to load ${file.path}:`, err);
                        this.updateStatus(file.key, 'Error', 'error');
                        throw err;
                    })
            );

            await Promise.all(promises);
            this.processDefinitions();
            this.enableSaveUpload();
            
        } catch (error) {
            alert("Error loading data files. Please check the 'relic_data' folder exists.");
        }

        const cellSizeSlider = document.querySelector('input[type="range"][min="65"]');
        if (cellSizeSlider) {
            cellSizeSlider.value = 80; // Ensure visual handle is at 80
            this.updateGridSettings(80); // Ensure grid renders at 80
        }
    }

    updateStatus(key, text, type) {
        const el = document.getElementById(`status-${key}`);
        if(el) {
            el.textContent = text;
            el.className = `status-${type}`;
        }
    }

    enableSaveUpload() {
        const input = document.getElementById('inp-save');
        const lbl = document.getElementById('lbl-save');
        if(input && lbl) {
            input.disabled = false;
            lbl.classList.remove('disabled');
        }
    }

    processDefinitions() {
        if (this.data.relics && this.data.relics.Relics) {
            this.data.relics.Relics.forEach(r => this.definitions.relics[r.id] = r);
        }
        
        if (this.data.affixes && this.data.affixes["Relic Affixes"]) {
            this.data.affixes["Relic Affixes"].forEach(a => this.definitions.affixes[a.id] = a);
        }

        // Capture Global Default Config
        if (this.data.affixes && this.data.affixes.relicUpgradeModifierConfig) {
            this.definitions.defaultUpgradeModifiers = this.data.affixes.relicUpgradeModifierConfig.upgradeModifier;
        }
    }

    loadSaveFile(input) {
        const file = input.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                this.data.save = JSON.parse(e.target.result);
                this.initEditorUI();
            } catch (err) {
                alert(`Error parsing save file: ${err.message}`);
            }
        };
        reader.readAsText(file);
    }

    initEditorUI() {
        const saveData = this.data.save._relicLoadoutsSaveData;
        const select = document.getElementById('loadoutSelect');
        select.innerHTML = '';
        select.disabled = false;

        if (saveData && saveData._loadouts) {
            saveData._loadouts.forEach((l, index) => {
                const opt = document.createElement('option');
                opt.value = index;
                opt.text = `Loadout ${index + 1} (${l.Items.length} items)`;
                select.appendChild(opt);
            });
            select.value = saveData._currentIndex !== undefined ? saveData._currentIndex : 0;
            this.currentLoadoutIndex = parseInt(select.value);
        }

        document.getElementById('downloadBtn').disabled = false;
        this.renderGrid();
    }

    switchLoadout() {
        const select = document.getElementById('loadoutSelect');
        this.currentLoadoutIndex = parseInt(select.value);
        this.selectedRelicIndex = -1;
        this.renderGrid();
        this.renderInspector();
    }

    updateGridSettings(size) {
        // 1. Update CSS Variable for visual grid
        document.documentElement.style.setProperty('--grid-cell-size', size + 'px');
        
        // 2. Update the Text Display
        const display = document.getElementById('cellSizeDisplay');
        if (display) display.textContent = size + 'px';

        // 3. Force re-calculation of relic positions
        this.renderGrid();
    }

    isValidPosition(targetItemIndex, targetX, targetY, loadout, gridWidth, gridHeight, validSlotsMask) {
        const item = loadout.Items[targetItemIndex];
        const def = this.definitions.relics[item._relicBaseDefinitionID];
        const size = this.getRelicSize(def);

        // 1. Boundary Check
        if (targetX < 0 || targetY < 0) return false;
        if (targetX + size.w > gridWidth) return false;
        if (targetY + size.h > gridHeight) return false;

        // 2. Blocked Slot Check (The shape mask)
        // iterate over every cell this relic would occupy
        for (let w = 0; w < size.w; w++) {
            for (let h = 0; h < size.h; h++) {
                const checkX = targetX + w;
                const checkY = targetY + h;

            // Convert XY to linear index for the shape mask array
            // Note: The mask usually runs row by row from top-left. 
            // Your grid renders rows 0..Height.
            // Visual Y increases downwards. Internal Y increases Upwards.
            // We need to map Internal Y back to Visual Row to check the mask.
                const visualRow = gridHeight - 1 - checkY;
                const maskIndex = visualRow * gridWidth + checkX;

            if (!validSlotsMask[maskIndex]) return false; // Slot is blocked
            }
        }

        // 3. Overlap Check with other items
        for (let i = 0; i < loadout.Items.length; i++) {
            if (i === targetItemIndex) continue; // Don't check against self

            const other = loadout.Items[i];
            const otherDef = this.definitions.relics[other._relicBaseDefinitionID];
            const otherSize = this.getRelicSize(otherDef);

            // AABB Collision Detection
            const noOverlap = 
                targetX >= other._position.x + otherSize.w || // Target is to the right
                targetX + size.w <= other._position.x ||      // Target is to the left
                targetY >= other._position.y + otherSize.h || // Target is above
                targetY + size.h <= other._position.y;        // Target is below

            if (!noOverlap) return false; // Collision detected
        }

        return true;
    }

    initDrag(e, item, index, element, source) {
        if (source !== 'copy_mode' && e.button !== 0) return;
        
        // Prevent default to stop browser image-dragging/text-selection
        e.preventDefault(); 
        
        // 1. Store Start State (Don't start dragging visual yet)
        this.dragStartX = e.clientX;
        this.dragStartY = e.clientY;
        
        this.dragItem = item;
        this.dragIndex = index;
        this.dragElement = element;
        this.dragSource = source; // 'main' or 'stash'

        const def = this.definitions.relics[item._relicBaseDefinitionID];
        this.dragItemSize = this.getRelicSize(def); // returns {w: 1, h: 2} etc.
        
        this.isDragging = false; // Flag to track if we actually moved

        // 2. Add Listeners
        this.boundMouseMove = (ev) => this.handleDragMove(ev);
        this.boundMouseUp = (ev) => this.handleDragEnd(ev);

        document.addEventListener('mousemove', this.boundMouseMove);
        document.addEventListener('mouseup', this.boundMouseUp);
    }

    handleDragMove(e) {
        // 1. Threshold Check (Start Drag)
        if (!this.isDragging) {
            const dist = Math.hypot(e.clientX - this.dragStartX, e.clientY - this.dragStartY);
            if (dist < 5) return; 

            this.isDragging = true;
            
            const rect = this.dragElement.getBoundingClientRect();
            this.dragOffsetX = this.dragStartX - rect.left;
            this.dragOffsetY = this.dragStartY - rect.top;
            
            this.dragElement.style.position = 'fixed';
            this.dragElement.style.left = rect.left + 'px';
            this.dragElement.style.top = rect.top + 'px';
            this.dragElement.style.zIndex = 9999;
            this.dragElement.style.pointerEvents = 'none'; 
            
            document.body.appendChild(this.dragElement); 
            this.dragElement.classList.add('dragging');

            this.selectedRelicIndex = this.dragIndex;
            this.selectedContainer = this.dragSource;
            
            this.dragGap = 4;
        }

        // 2. Update Position & Smooth Scale
        if (this.isDragging) {
            const mx = e.clientX;
            const my = e.clientY;

            // A. Move Element
            this.dragElement.style.left = `${mx - this.dragOffsetX}px`;
            this.dragElement.style.top = `${my - this.dragOffsetY}px`;

            // B. Get Panel Metrics
            const stashRect = document.getElementById('stashContainer').getBoundingClientRect();
            const mainRect = document.getElementById('gridContainer').getBoundingClientRect();

            // Calculate Centers
            const stashCenterX = stashRect.left + stashRect.width / 2;
            const mainCenterX = mainRect.left + mainRect.width / 2;

            // C. Calculate Interpolation Factor (t)
            // t = 0 (at Stash Center) -> t = 1 (at Main Center)
            let t = (mx - stashCenterX) / (mainCenterX - stashCenterX);
            
            // Clamp t between 0.0 and 1.0 to prevent over-shrinking or over-growing
            t = Math.max(0, Math.min(1, t));

            // D. Lerp (Linear Interpolation) the Cell Size
            const startSize = this.stashCellSize; // e.g. 60
            const endSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--grid-cell-size')); // e.g. 80
            
            // Formula: Current = Start + Percent * (End - Start)
            const currentCellSize = startSize + t * (endSize - startSize);

            // E. Apply Calculated Size
            const w = this.dragItemSize.w;
            const h = this.dragItemSize.h;
            const gap = 4;

            const newPixelW = w * currentCellSize + (w - 1) * gap;
            const newPixelH = h * currentCellSize + (h - 1) * gap;

            this.dragElement.style.width = `${newPixelW}px`;
            this.dragElement.style.height = `${newPixelH}px`;
        }

        if (this.isDragging) {
            const trash = document.getElementById('trashZone');
            const r = trash.getBoundingClientRect();
            if (e.clientX >= r.left && e.clientX <= r.right && 
                e.clientY >= r.top && e.clientY <= r.bottom) {
                trash.classList.add('drag-over');
            } else {
                trash.classList.remove('drag-over');
            }
        }
    }

    handleDragEnd(e) {
        document.removeEventListener('mousemove', this.boundMouseMove);
        document.removeEventListener('mouseup', this.boundMouseUp);
        
        // Cleanup Trash Visuals
        document.getElementById('trashZone').classList.remove('drag-over');

        if (!this.isDragging) {
            // [Existing Click Handling...]
            if (this.dragSource === 'copy_mode') {
                 this.dragElement.remove(); // Just cleanup if they right-clicked but didnt move?
                 return; 
            }
            this.selectedRelicIndex = this.dragIndex;
            this.selectedContainer = this.dragSource; 
            this.renderGrid();      
            this.renderInspector(); 
            return;
        }

        this.isDragging = false;
        this.dragElement.remove();

        // Detect Target
        const mainGrid = document.getElementById('gridContainer');
        const stashGrid = document.getElementById('stashContainer');
        const trashZone = document.getElementById('trashZone'); // NEW

        const mx = e.clientX;
        const my = e.clientY;

        let targetType = null;
        
        // Helper check
        const isInside = (r) => mx >= r.left && mx <= r.right && my >= r.top && my <= r.bottom;

        if (isInside(mainGrid.getBoundingClientRect())) {
            targetType = 'main';
        } else if (isInside(stashGrid.getBoundingClientRect())) {
            targetType = 'stash';
        } else if (isInside(trashZone.getBoundingClientRect())) { // NEW
            targetType = 'trash';
        }

        if (targetType) {
            this.attemptDrop(targetType, mx, my);
        } else {
            // If dropped in void...
            if (this.dragSource === 'copy_mode') {
                // Cancel copy -> Do nothing (item disappears)
            } else {
                this.renderGrid(); // Snap back
            }
        }
    }

    attemptDrop(targetType, mouseX, mouseY) {
        // 1. TRASH LOGIC
        if (targetType === 'trash') {
            if (this.dragSource === 'copy_mode') {
                // Deleted a copy before placing it? Just do nothing.
                return;
            }
            // Save to history
            this.deletedItemHistory.push({
                item: this.dragItem,
                source: this.dragSource, // 'main' or 'stash'
                // Save exact copy of position in case we need it
                originalPos: { ...this.dragItem._position } 
            });

            // Delete existing item
            if (this.dragSource === 'main') {
                const loadout = this.data.save._relicLoadoutsSaveData._loadouts[this.currentLoadoutIndex];
                loadout.Items.splice(this.dragIndex, 1);
            } else if (this.dragSource === 'stash') {
                this.stashItems.splice(this.dragIndex, 1);
            }
            
            this.selectedRelicIndex = -1; // Deselect
            this.renderGrid();
            this.renderInspector();
            return;
        }

        // 2. Standard Drop Logic Setup
        const isStash = (targetType === 'stash');
        const container = isStash ? document.getElementById('stashContainer') : document.getElementById('gridContainer');
        const rect = container.getBoundingClientRect();
        
        // Cell Size Logic
        let targetCellSize;
        if (isStash) {
            targetCellSize = this.stashCellSize;
        } else {
            targetCellSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--grid-cell-size'));
        }
        
        const gridPadding = 10;
        const dragTotalUnit = targetCellSize + this.dragGap;
        
        const relX = mouseX - rect.left - this.dragOffsetX - gridPadding;
        const relY = mouseY - rect.top - this.dragOffsetY - gridPadding;
        
        const targetX = Math.round(relX / dragTotalUnit);
        const visualY = Math.round(relY / dragTotalUnit);

        // 3. Grid References
        let gridW, gridH, targetArray;
        let finalDataY = visualY; 
        
        const shapeConfig = this.data.config.playerInventoryShapeTiers;
        const currentShape = shapeConfig[shapeConfig.length - 1];
        const loadout = this.data.save._relicLoadoutsSaveData._loadouts[this.currentLoadoutIndex];
        const def = this.definitions.relics[this.dragItem._relicBaseDefinitionID];
        const size = this.getRelicSize(def);

        if (isStash) {
            gridW = this.stashWidth;
            gridH = this.stashHeight;
            targetArray = this.stashItems;
        } else {
            gridW = currentShape.width;
            gridH = currentShape.height;
            targetArray = loadout.Items;
            finalDataY = gridH - visualY - size.h;
        }

        // 4. Validation & Collision
        if (targetX < 0 || visualY < 0 || targetX + size.w > gridW || visualY + size.h > gridH) {
            if (this.dragSource !== 'copy_mode') this.renderGrid(); 
            return;
        }

        // Filter collision list
        let collisionList = targetArray;
        // CRITICAL: If copying, we check against EVERYTHING in the target (because the new item isn't in there yet)
        // If moving existing item, we ignore self.
        if (this.dragSource === targetType && this.dragSource !== 'copy_mode') {
            collisionList = targetArray.filter((_, i) => i !== this.dragIndex);
        }

        for (let other of collisionList) {
            const oDef = this.definitions.relics[other._relicBaseDefinitionID];
            const oSize = this.getRelicSize(oDef);
            const overlap = !(targetX >= other._position.x + oSize.w || targetX + size.w <= other._position.x || finalDataY >= other._position.y + oSize.h || finalDataY + size.h <= other._position.y);
            if (overlap) { 
                if (this.dragSource !== 'copy_mode') this.renderGrid(); 
                return; 
            }
        }

        if (!isStash) {
             for(let w = 0; w < size.w; w++) {
                 for(let h = 0; h < size.h; h++) {
                     const cx = targetX + w;
                     const cy = finalDataY + h;
                     const vRow = gridH - 1 - cy; 
                     if (!currentShape.shape[vRow * gridW + cx]) {
                         if (this.dragSource !== 'copy_mode') this.renderGrid(); 
                         return; 
                     }
                 }
             }
        }

        // 5. Commit Move
        
        // A. Remove from old (ONLY if NOT copying)
        if (this.dragSource !== 'copy_mode') {
            if (this.dragSource === 'main') {
                loadout.Items.splice(this.dragIndex, 1);
            } else if (this.dragSource === 'stash') {
                this.stashItems.splice(this.dragIndex, 1);
            }
        }

        // B. Update Coords
        this.dragItem._position.x = targetX;
        this.dragItem._position.y = finalDataY;

        // C. Add to new
        if (targetType === 'main') {
            loadout.Items.push(this.dragItem);
        } else {
            this.stashItems.push(this.dragItem);
        }

        this.selectedContainer = targetType;
        this.selectedRelicIndex = (targetType === 'main' ? loadout.Items.length : this.stashItems.length) - 1;

        this.renderGrid();
        this.renderInspector();
    }

    undoLastDelete() {
        if (this.deletedItemHistory.length === 0) {
            console.log("Nothing to undo.");
            return;
        }

        // 1. Retrieve last deleted item
        const record = this.deletedItemHistory.pop();
        const item = record.item;
        
        // 2. Determine Destination
        let targetArray, gridW, gridH, currentShape;
        const isStash = (record.source === 'stash');

        if (isStash) {
            targetArray = this.stashItems;
            gridW = this.stashWidth;
            gridH = this.stashHeight;
        } else {
            const loadout = this.data.save._relicLoadoutsSaveData._loadouts[this.currentLoadoutIndex];
            targetArray = loadout.Items;
            
            const shapeConfig = this.data.config.playerInventoryShapeTiers;
            currentShape = shapeConfig[shapeConfig.length - 1];
            gridW = currentShape.width;
            gridH = currentShape.height;
        }

        // 3. Collision Check (Crucial: The spot might now be taken!)
        const def = this.definitions.relics[item._relicBaseDefinitionID];
        const size = this.getRelicSize(def);
        
        // Check against all CURRENT items in that list
        const isBlocked = targetArray.some(other => {
            const oDef = this.definitions.relics[other._relicBaseDefinitionID];
            const oSize = this.getRelicSize(oDef);
            
            return !(
                item._position.x >= other._position.x + oSize.w || 
                item._position.x + size.w <= other._position.x || 
                item._position.y >= other._position.y + oSize.h || 
                item._position.y + size.h <= other._position.y
            );
        });

        if (isBlocked) {
            alert("Cannot undo: The original slot is now occupied.");
            // Optional: Push back to history so it's not lost? 
            // this.deletedItemHistory.push(record); 
            return;
        }

        // 4. Restore Item
        targetArray.push(item);
        
        // Select the restored item
        this.selectedContainer = record.source;
        this.selectedRelicIndex = targetArray.length - 1;

        this.renderGrid();
        this.renderInspector();
    }

    renderGrid() {
        const container = document.getElementById('gridContainer');
        container.innerHTML = '';

        if (!this.data.config) return;

        const shapeConfig = this.data.config.playerInventoryShapeTiers;
        const currentShape = shapeConfig[shapeConfig.length - 1]; 
        
        const width = currentShape.width;
        const height = currentShape.height;

        container.style.gridTemplateColumns = `repeat(${width}, var(--grid-cell-size))`;
        container.style.gridTemplateRows = `repeat(${height}, var(--grid-cell-size))`;

        currentShape.shape.forEach(isValid => {
            const div = document.createElement('div');
            div.className = `grid-slot ${isValid ? '' : 'blocked'}`;
            container.appendChild(div);
        });

        const loadout = this.data.save._relicLoadoutsSaveData._loadouts[this.currentLoadoutIndex];
        
        loadout.Items.forEach((item, index) => {
            const def = this.definitions.relics[item._relicBaseDefinitionID];
            const size = this.getRelicSize(def);
            
            const el = document.createElement('div');
            el.className = `relic-item rarity-${item._eRelicRarity}`;
            if (this.selectedContainer === 'main' && index === this.selectedRelicIndex) {
                el.classList.add('selected');
            }

            const cellSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--grid-cell-size'));
            const gap = 4;

            const visualY = height - item._position.y - size.h;
            
            el.style.left = `${item._position.x * (cellSize + gap) + 10}px`; 
            el.style.top = `${visualY * (cellSize + gap) + 10}px`;
            el.style.width = `${size.w * cellSize + (size.w - 1) * gap}px`;
            el.style.height = `${size.h * cellSize + (size.h - 1) * gap}px`;

            el.innerHTML = `<strong>${def ? this.extractName(def) : 'Unknown'}</strong>`;
            
            el.onmousedown = (e) => {
                e.stopPropagation(); // Stop grid interaction
                // Start Drag Logic
                this.initDrag(e, item, index, el, 'main');
            };

            el.oncontextmenu = (e) => {
                e.preventDefault(); 
                e.stopPropagation();
                this.startCopy(e, item);
            };

            container.appendChild(el);
        });
        this.renderStash();
    }

    renderStash() {
        const container = document.getElementById('stashContainer');
        container.innerHTML = '';

        // 1. Set Grid Template using Fixed Size
        container.style.gridTemplateColumns = `repeat(${this.stashWidth}, ${this.stashCellSize}px)`;
        container.style.gridTemplateRows = `repeat(${this.stashHeight}, ${this.stashCellSize}px)`;

        // Draw Background Slots
        const totalSlots = this.stashWidth * this.stashHeight;
        for(let i=0; i<totalSlots; i++) {
            const div = document.createElement('div');
            div.className = 'grid-slot';
            // Force slots to fixed size
            div.style.width = `${this.stashCellSize}px`;
            div.style.height = `${this.stashCellSize}px`;
            container.appendChild(div);
        }

        // Draw Items
        this.stashItems.forEach((item, index) => {
            const def = this.definitions.relics[item._relicBaseDefinitionID];
            const size = this.getRelicSize(def);
        
            const el = document.createElement('div');
            el.className = `relic-item rarity-${item._eRelicRarity}`;
            if (this.selectedContainer === 'stash' && index === this.selectedRelicIndex) el.classList.add('selected');
        
            // 2. Use Fixed Size for Item Calculations
            const cellSize = this.stashCellSize;
            const gap = 4;

            el.style.left = `${item._position.x * (cellSize + gap) + 10}px`; 
            el.style.top = `${item._position.y * (cellSize + gap) + 10}px`;
            el.style.width = `${size.w * cellSize + (size.w - 1) * gap}px`;
            el.style.height = `${size.h * cellSize + (size.h - 1) * gap}px`;
        
            el.innerHTML = `<strong>${def ? this.extractName(def) : 'Unknown'}</strong>`;

            el.onmousedown = (e) => {
                e.stopPropagation();
                this.initDrag(e, item, index, el, 'stash');
            };

            el.oncontextmenu = (e) => {
                e.preventDefault();
                e.stopPropagation();
                this.startCopy(e, item);
            };

            container.appendChild(el);
        });
    }

    calculateRealValue(roll, range, level, affixDef) {
        if (!range) return null;

        const [min, max] = range;
        const baseVal = min + roll * (max - min);
        const corrupted = min === max;

        const override =
            affixDef?.upgradeModifierOverride
                ? parseFloat(affixDef.upgradeModifierOverride[level] || 0)
                : null;

        const multiplier =
            override !== null
                ? override
                : this.getUpgradeMultiplier(level, affixDef);

        const config = affixDef?.relicUpgradeModifierConfig || {};
        const modType = config.modifierType || affixDef?.modifierType || "Additive";

        let finalVal;

        if (corrupted) {
            if (Number.isInteger(min) && Number.isInteger(max)) {
                return `+${baseVal.toFixed(2)}`;
            }

            if (modType === "Multiplicative") {
                finalVal = baseVal * (multiplier || 1);
                return `+${(finalVal * 100).toFixed(2)}%`;
            }

            finalVal = baseVal + (multiplier || 0);

            if (finalVal >= 1.0 && finalVal <= 2.0 && max <= 2.0) {
                return `+${((finalVal - 1.0) * 100).toFixed(2)}%`;
            }

            if (finalVal > 0 && finalVal <= 1.0) {
                return `+${(finalVal * 100).toFixed(2)}%`;
            }

            return `+${finalVal.toFixed(2)}`;
        }

        // Non-corrupted
        if (override !== null) {
            finalVal = baseVal + override;
        } else {
            finalVal = baseVal * multiplier;
        }

        // Normalize 1.x stats
        if (max <= 2.0 && min > 1.0) {
            finalVal -= 1.0;
        }

        if (max <= 2.0) {
            return `+${(finalVal * 100).toFixed(2)}%`;
        }

        return `+${finalVal.toFixed(2)}`;
    }

    toggleLimitUnlock(isChecked) {
        this.ui_unlockLimits = isChecked;
        this.renderInspector();
    }

    renderInspector() {
        const container = document.getElementById('inspectorContent');
        container.innerHTML = '';

        const item = this.getSelectedItem(); // Use the new helper

        if (!item) {
            container.innerHTML = '<p style="color: #666; font-style: italic;">Select a relic to edit details.</p>';
            return;
        }

        const def = this.definitions.relics[item._relicBaseDefinitionID];

        // Header
        const header = document.createElement('div');
        header.innerHTML = `<h3>${def ? this.extractName(def) : 'Unknown Relic'}</h3>`;
        container.appendChild(header);

        // Core Stats
        container.appendChild(this.createInput('Level (0-5)', 'number', item._upgradeLevel, (v) => {
            item._upgradeLevel = Math.min(5, Math.max(0, parseInt(v))); 
            this.renderInspector(); 
        }));
        
        // Tier (1-based direct mapping)
        const currentTier = item._tier || 1; 
        container.appendChild(this.createInput('Tier (1-4)', 'number', currentTier, (v) => {
            const val = Math.min(4, Math.max(1, parseInt(v)));
            item._tier = val; 
            // Sync affixes to match item tier
            if (item._affixesData) item._affixesData.forEach(a => a._tier = val);
            if (item._implicitAffixesData) item._implicitAffixesData.forEach(i => {
                if (i._relicAffixData) i._relicAffixData._tier = val;
            });
            this.renderInspector(); 
        }));
        
        container.appendChild(this.createInput('Rarity (0-3)', 'number', item._eRelicRarity, (v) => {
            item._eRelicRarity = Math.min(3, Math.max(0, parseInt(v)));
            this.renderGrid();
        }));
        
        // --- FIX START: Decouple "High Rolls" from "Ascended Flag" ---
        
        // 1. Detect if we need to show extended sliders (Divined/High Rolls)
        const hasHighRolls = (item._affixesData && item._affixesData.some(a => a._rollValue > 1.0)) || 
                             (item._implicitAffixesData && item._implicitAffixesData.some(i => i._relicAffixData._rollValue > 1.0));
        
        // 2. Determine UI State (Unlocked if high rolls exist OR if user toggles checkbox)
        // We use a temporary class property 'ui_unlockLimits' so it persists during the session but isn't saved to JSON
        const isUnlocked = (this.ui_unlockLimits !== undefined) ? this.ui_unlockLimits : hasHighRolls;

        // 3. Render "Unlock Limits" Checkbox (Purely UI)
        const unlockDiv = document.createElement('div');
        unlockDiv.className = 'form-group';
        unlockDiv.innerHTML = `
            <label style="display:inline-flex; align-items:center; gap:8px; color:#fff;">
                <input type="checkbox" ${isUnlocked ? 'checked' : ''} 
                onchange="app.toggleLimitUnlock(this.checked)"> Unlock Limits (Divined)
            </label>
        `;
        container.appendChild(unlockDiv);
        
        const currentLevel = item._upgradeLevel;
        if (!item._affixesData) item._affixesData = [];
        if (!item._implicitAffixesData) item._implicitAffixesData = [];

        // Pass the 'isUnlocked' flag to the renderers instead of reading item._ascended
        this.renderAffixList(container, item._affixesData, "Affixes", currentTier, currentLevel, isUnlocked);
        this.renderImplicitAffixList(container, item._implicitAffixesData, "Implicit Affixes", currentTier, currentLevel, isUnlocked);
    }

    // --- MODAL LOGIC START ---
    
    openAffixModal(currentId, callback) {
        this.pendingAffixCallback = callback;
        
        const modal = document.getElementById('affixModal');
        const list = document.getElementById('affixSearchResults');
        const input = document.getElementById('affixSearchInput');
        
        modal.style.display = 'flex';
        input.value = '';
        input.focus();
        
        // Pre-generate list
        this.allAffixOptions = Object.values(this.definitions.affixes).map(def => ({
            id: def.id,
            name: this.getAffixName(def.id),
            rawDef: def
        })).sort((a, b) => a.name.localeCompare(b.name));

        this.renderAffixSearchList(this.allAffixOptions);
    }

    closeModal() {
        document.getElementById('affixModal').style.display = 'none';
        this.pendingAffixCallback = null;
    }

    getLevenshteinDistance(a, b) {
        if (a.length === 0) return b.length;
        if (b.length === 0) return a.length;

        const matrix = [];

        // Increment along the first column of each row
        for (let i = 0; i <= b.length; i++) {
            matrix[i] = [i];
        }

        // Increment each column in the first row
        for (let j = 0; j <= a.length; j++) {
            matrix[0][j] = j;
        }

        // Fill in the rest of the matrix
        for (let i = 1; i <= b.length; i++) {
            for (let j = 1; j <= a.length; j++) {
                if (b.charAt(i - 1) === a.charAt(j - 1)) {
                    matrix[i][j] = matrix[i - 1][j - 1];
                } else {
                    matrix[i][j] = Math.min(
                        matrix[i - 1][j - 1] + 1, // substitution
                        Math.min(
                            matrix[i][j - 1] + 1, // insertion
                            matrix[i - 1][j] + 1  // deletion
                        )
                    );
                }
            }
        }

        return matrix[b.length][a.length];
    }

    filterAffixes() {
        const rawQuery = document.getElementById('affixSearchInput').value.toLowerCase().trim();
        
        if (!rawQuery) {
            this.renderAffixSearchList(this.allAffixOptions);
            return;
        }

        // 1. Split user input into individual words (tokens)
        // e.g., "All skils" -> ["all", "skils"]
        const queryTokens = rawQuery.split(/[\s-]+/).filter(t => t.length > 0);

        const filtered = this.allAffixOptions.filter(opt => {
            const name = opt.name.toLowerCase();
            const id = String(opt.id);

            // Optimization: If the full phrase is an exact match, keep it immediately
            if (name.includes(rawQuery) || id.includes(rawQuery)) {
                opt._matchType = 'exact';
                return true;
            }

            // 2. Token Matching Strategy
            // We split the affix name into words: "All Skills - Damage" -> ["all", "skills", "damage"]
            const nameTokens = name.split(/[\s-]+/);

            // We check: Does EVERY word in the user's query find a match in the affix name?
            const allTokensMatched = queryTokens.every(qToken => {
                
                // A. Check for partial substring match (e.g., "Dam" matches "Damage")
                if (nameTokens.some(nT => nT.includes(qToken))) return true;

                // B. Check for fuzzy/typo match (e.g., "skils" matches "Skills")
                // Only run this on words of 3+ letters to avoid noise
                if (qToken.length >= 3) {
                    const maxEdits = qToken.length > 5 ? 2 : 1;
                    return nameTokens.some(nT => {
                        // Optimization: Skip if lengths are too different
                        if (Math.abs(nT.length - qToken.length) > maxEdits) return false;
                        return this.getLevenshteinDistance(qToken, nT) <= maxEdits;
                    });
                }
                
                return false;
            });

            if (allTokensMatched) {
                opt._matchType = 'fuzzy';
                return true;
            }

            return false;
        });

        // 3. Sort Results: Prioritize exact matches
        filtered.sort((a, b) => {
            if (a._matchType === 'exact' && b._matchType !== 'exact') return -1;
            if (a._matchType !== 'exact' && b._matchType === 'exact') return 1;
            return a.name.localeCompare(b.name);
        });

        this.renderAffixSearchList(filtered);
    }

    renderAffixSearchList(items) {
        const container = document.getElementById('affixSearchResults');
        container.innerHTML = '';
        
        if (items.length === 0) {
            container.innerHTML = '<div style="padding:10px; color:#666;">No affixes found.</div>';
            return;
        }

        items.forEach(item => {
            const div = document.createElement('div');
            div.className = 'search-item';
            div.innerHTML = `
                <strong>${item.name}</strong>
                <small>ID: ${item.id}</small>
            `;
            div.onclick = () => {
                if (this.pendingAffixCallback) {
                    this.pendingAffixCallback(item.id);
                }
                this.closeModal();
            };
            container.appendChild(div);
        });
    }

    // --- MODAL LOGIC END ---

    createAffixSelect(label, selectedId, onChange) {
        const div = document.createElement('div');
        div.className = 'form-group';
        
        const lbl = document.createElement('label');
        lbl.textContent = label;
        
        const btn = document.createElement('button');
        btn.className = 'btn-select-affix';
        
        // --- DIRECT STYLE FIX ---
        // Force dark theme colors by default
        btn.style.backgroundColor = '#161b22';
        btn.style.borderColor = '#30363d';
        btn.style.color = '#c9d1d9';
        btn.style.textAlign = 'left';
        // ------------------------
        
        // Show current name on the button
        const currentName = this.definitions.affixes[selectedId] 
            ? this.getAffixName(selectedId) 
            : `Unknown ID: ${selectedId}`;
            
        btn.innerHTML = `${currentName} <span style="float:right; color:#888;">&#9660;</span>`;
        
        btn.onclick = () => {
            this.openAffixModal(selectedId, (newId) => {
                onChange(newId);
            });
        };
        
        div.appendChild(lbl);
        div.appendChild(btn);
        return div;
    }

    renderAffixList(container, affixes, title, tier, level, isUnlocked) {
        if (!affixes) return;
        
        container.appendChild(document.createElement('hr'));
        container.appendChild(Object.assign(document.createElement('h4'), {textContent: title}));

        const list = document.createElement('div');
        list.className = 'affix-list';

        affixes.forEach((affix, idx) => {
            const div = document.createElement('div');
            div.className = 'affix-item';
            
            // Lookup Definition
            const def = this.definitions.affixes[affix._relicAffixDefinitionId];
            
            // Name Label
            const nameLabel = document.createElement('label');
            nameLabel.style.color = '#fff';
            nameLabel.innerHTML = this.getAffixName(affix._relicAffixDefinitionId);
            
            // Multiplier Tag
            const override = this.getAdditiveOverrideConfig(def);
            if (!override) {
                const mult = this.getUpgradeMultiplier(level, def);
                if(mult > 1.0) {
                     nameLabel.innerHTML += ` <span class="multiplier-tag">x${mult}</span>`;
                }
            }
            div.appendChild(nameLabel);

            // Range & Value
            const range = this.getAffixRange(affix._relicAffixDefinitionId, tier);
            if (range) {
                const realVal = document.createElement('span');
                realVal.className = 'calculated-value';
                realVal.textContent = this.calculateRealValue(affix._rollValue, range, level, def);
                div.appendChild(realVal);

                const rangeInfo = document.createElement('span');
                rangeInfo.className = 'range-info';
                rangeInfo.textContent = `T${tier} Range: [${range[0]} - ${range[1]}]`;
                div.insertBefore(rangeInfo, nameLabel);
            }

            // Dropdown
            div.appendChild(this.createAffixSelect('Affix Name', affix._relicAffixDefinitionId, (v) => {
                affix._relicAffixDefinitionId = parseInt(v);
                this.renderInspector();
            }));

            // --- FIX: Slider Range Logic ---
            // Decoupled from item._ascended. Uses UI-only 'isUnlocked' flag.
            const maxVal = Math.max(1.0, affix._rollValue, isUnlocked ? 1.2 : 1.0);
            
            const sliderGroup = document.createElement('div');
            sliderGroup.className = 'form-group';
            sliderGroup.innerHTML = `<label>Roll Coefficient (0.0 - ${maxVal.toFixed(1)})</label>`;
            
            const sliderContainer = document.createElement('div');
            sliderContainer.className = 'slider-container';

            const slider = document.createElement('input');
            slider.type = 'range';
            slider.min = 0;
            slider.max = maxVal;
            slider.step = 0.001;
            slider.value = affix._rollValue;

            const numInput = document.createElement('input');
            numInput.type = 'number';
            numInput.step = 0.001;
            numInput.value = affix._rollValue.toFixed(3);
            numInput.style.width = '80px';

            slider.oninput = (e) => {
                const val = parseFloat(e.target.value);
                affix._rollValue = val;
                numInput.value = val.toFixed(3);
                if (range) {
                    div.querySelector('.calculated-value').textContent = this.calculateRealValue(val, range, level, def);
                }
            };
            numInput.onchange = (e) => {
                let val = parseFloat(e.target.value);
                // Clamp to the dynamic maxVal we calculated above
                if (val > maxVal) val = maxVal; 
                affix._rollValue = val;
                e.target.value = val.toFixed(3);
                slider.value = val;
                this.renderInspector(); 
            };

            sliderContainer.appendChild(slider);
            sliderContainer.appendChild(numInput);
            sliderGroup.appendChild(sliderContainer);
            div.appendChild(sliderGroup);

            // Locked Checkbox
            const lockCheck = document.createElement('div');
            lockCheck.innerHTML = `
                <label style="display:inline-flex; align-items:center; gap:5px;">
                    <input type="checkbox" ${affix._locked ? 'checked' : ''} 
                    onchange="app.updateAffixLock(${idx}, this.checked, false)"> Locked
                </label>
            `;
            div.appendChild(lockCheck);

            // Footer
            const footer = document.createElement('div');
            footer.className = 'affix-footer';
            
            const btnRemove = document.createElement('button');
            btnRemove.className = 'btn-remove';
            btnRemove.textContent = 'Remove';
            btnRemove.onclick = () => this.removeAffix(idx, false);
            
            footer.appendChild(btnRemove);
            div.appendChild(footer);

            list.appendChild(div);
        });

        // Add Button
        const btnAdd = document.createElement('button');
        btnAdd.className = 'btn-add';
        btnAdd.textContent = '+ Add Affix';
        btnAdd.onclick = () => this.addAffix(false);
        list.appendChild(btnAdd);

        container.appendChild(list);
    }

    renderImplicitAffixList(container, implicitData, title, tier, level, isUnlocked) {
        if (!implicitData || implicitData.length === 0) return;

        container.appendChild(document.createElement('hr'));
        // Add count to header so you see "Implicit Affixes (4)"
        container.appendChild(Object.assign(document.createElement('h4'), {
            textContent: `${title} (${implicitData.length})`
        }));
        
        const list = document.createElement('div');
        list.className = 'affix-list';

        // Shortcut to mapping data
        const mapping = this.data.implicit_mapping;

        implicitData.forEach((impObj, idx) => {
            // --- NEW: GAME LIMIT WARNING ---
            // Insert a warning separator before the 4th item (index 3)
            if (idx === 3) {
                const limitWarning = document.createElement('div');
                limitWarning.style.color = '#d29922'; // Orange
                limitWarning.style.textAlign = 'center';
                limitWarning.style.fontSize = '0.75em';
                limitWarning.style.fontWeight = 'bold';
                limitWarning.style.margin = '15px 0 5px 0';
                limitWarning.style.borderTop = '1px dashed #d29922';
                limitWarning.style.paddingTop = '5px';
                limitWarning.innerHTML = ' GAME DISPLAY LIMIT (TOP 3 SHOWN) ';
                list.appendChild(limitWarning);
            }
            // -------------------------------

            const affix = impObj._relicAffixData;
            const defId = affix._relicAffixDefinitionId;
            const def = this.definitions.affixes[defId];

            // --- 1. AUTO-DETECT LOGIC ---
            const range = this.getAffixRange(defId, tier);
            
            // Rule A: Corrupted (Min == Max)
            if (range && range[0] === range[1]) {
                impObj._eImplicitAffixCategory = 3; 
            }
            // Rule B: Standard (Check Map or Default to -1)
            else if (impObj._eImplicitAffixCategory === undefined || impObj._eImplicitAffixCategory === null) {
                 if (mapping && mapping[defId] !== undefined) {
                     impObj._eImplicitAffixCategory = mapping[defId];
                 } else {
                     impObj._eImplicitAffixCategory = -1; 
                 }
            }

            const div = document.createElement('div');
            div.className = 'affix-item';

            // 2. VISUALS
            const catColors = {
                0: '#e5534b', // Fury
                1: '#58a6ff', // Faith
                2: '#3fb950', // Discipline
                3: '#a371f7', // Corrupted
                [-1]: '#888888' // None
            };

            const currentCat = impObj._eImplicitAffixCategory;
            const currentColor = catColors[currentCat] || '#888888';
            
            div.style.borderColor = currentColor;
            div.style.borderLeftWidth = '5px'; 
            // Dim items past the limit slightly to indicate they might be inactive
            if (idx >= 3) div.style.opacity = '0.6'; 

            // 3. TYPE HEADER
            const catHeader = document.createElement('div');
            catHeader.style.marginBottom = '8px';
            catHeader.style.display = 'flex';
            catHeader.style.alignItems = 'center';
            
            const catLabel = document.createElement('span');
            catLabel.style.fontSize = '0.7em';
            catLabel.style.color = '#888';
            catLabel.style.marginRight = '6px';
            catLabel.textContent = "TYPE:";
            
            const catSelect = document.createElement('select');
            catSelect.style.backgroundColor = 'transparent';
            catSelect.style.color = currentColor;
            catSelect.style.border = 'none';
            catSelect.style.fontSize = '0.75em';
            catSelect.style.fontWeight = 'bold';
            catSelect.style.textTransform = 'uppercase';
            catSelect.style.cursor = 'pointer';
            catSelect.style.outline = 'none';
            
            [-1, 0, 1, 2, 3].forEach(id => {
                const opt = document.createElement('option');
                opt.value = id;
                opt.textContent = this.getImplicitCategoryName(id);
                opt.style.backgroundColor = '#161b22';
                opt.style.color = catColors[id] || '#888';
                if (currentCat === id) opt.selected = true;
                catSelect.appendChild(opt);
            });

            catSelect.onchange = (e) => {
                impObj._eImplicitAffixCategory = parseInt(e.target.value);
                this.renderInspector(); 
            };

            catHeader.appendChild(catLabel);
            catHeader.appendChild(catSelect);
            div.appendChild(catHeader);

            // 4. Name Label
            const nameLabel = document.createElement('label');
            nameLabel.style.color = '#add8e6';
            nameLabel.innerHTML = this.getAffixName(defId);
            
            const override = this.getAdditiveOverrideConfig(def);
            if (!override) {
                const mult = this.getUpgradeMultiplier(level, def);
                if(mult > 1.0) nameLabel.innerHTML += ` <span class="multiplier-tag">x${mult}</span>`;
            }
            div.appendChild(nameLabel);

            // 5. Range Display
            if (range) {
                const realVal = document.createElement('span');
                realVal.className = 'calculated-value';
                realVal.textContent = this.calculateRealValue(affix._rollValue, range, level, def);
                div.appendChild(realVal);

                const rangeInfo = document.createElement('span');
                rangeInfo.className = 'range-info';
                rangeInfo.textContent = `T${tier} Range: [${range[0]} - ${range[1]}]`;
                div.insertBefore(rangeInfo, nameLabel);
            }

            // 6. Affix Selector (Callback)
            const affixSelectWrapper = this.createAffixSelect('Affix Name', defId, (v) => {
                const newId = parseInt(v);
                affix._relicAffixDefinitionId = newId;

                // RE-RUN LOGIC ON CHANGE
                const newRange = this.getAffixRange(newId, tier);

                if (newRange && newRange[0] === newRange[1]) {
                    impObj._eImplicitAffixCategory = 3; // Corrupted
                } else if (mapping && mapping[newId] !== undefined) {
                    impObj._eImplicitAffixCategory = mapping[newId]; // Mapped
                } else {
                    impObj._eImplicitAffixCategory = -1; // Unknown
                }

                this.renderInspector();
            });

            const innerBtn = affixSelectWrapper.querySelector('button');
            div.appendChild(affixSelectWrapper);

            // 7. Slider
            const maxVal = Math.max(1.0, affix._rollValue, isUnlocked ? 1.2 : 1.0);
            const sliderGroup = document.createElement('div');
            sliderGroup.className = 'form-group';
            sliderGroup.innerHTML = `<label>Roll Coefficient</label>`;
            const sliderContainer = document.createElement('div');
            sliderContainer.className = 'slider-container';

            const slider = document.createElement('input');
            slider.type = 'range';
            slider.min = 0;
            slider.max = maxVal;
            slider.step = 0.001;
            slider.value = affix._rollValue;

            const numInput = document.createElement('input');
            numInput.type = 'number';
            numInput.step = 0.001;
            numInput.value = affix._rollValue.toFixed(3);
            numInput.style.width = '80px';

            slider.oninput = (e) => {
                const val = parseFloat(e.target.value);
                affix._rollValue = val;
                numInput.value = val.toFixed(3);
                if(range) div.querySelector('.calculated-value').textContent = this.calculateRealValue(val, range, level, def);
            };
            numInput.onchange = (e) => {
                let val = parseFloat(e.target.value);
                if (val > maxVal) val = maxVal;
                affix._rollValue = val;
                e.target.value = val.toFixed(3);
                slider.value = affix._rollValue;
                this.renderInspector();
            };

            sliderContainer.appendChild(slider);
            sliderContainer.appendChild(numInput);
            sliderGroup.appendChild(sliderContainer);
            div.appendChild(sliderGroup);

            // 8. Remove
            const footer = document.createElement('div');
            footer.className = 'affix-footer';
            const btnRemove = document.createElement('button');
            btnRemove.className = 'btn-remove';
            btnRemove.textContent = 'Remove';
            btnRemove.onclick = () => this.removeAffix(idx, true);
            
            footer.appendChild(btnRemove);
            div.appendChild(footer);

            list.appendChild(div);
        });

        const btnAdd = document.createElement('button');
        btnAdd.className = 'btn-add';
        btnAdd.textContent = '+ Add Implicit';
        btnAdd.onclick = () => this.addAffix(true);
        list.appendChild(btnAdd);

        container.appendChild(list);
    }

    createInput(label, type, value, onChange, step=1) {
        const div = document.createElement('div');
        div.className = 'form-group';
        
        const lbl = document.createElement('label');
        lbl.textContent = label;
        
        const input = document.createElement('input');
        input.type = type;
        input.value = value;
        if(type === 'number') input.step = step;
        
        input.onchange = (e) => onChange(e.target.value);
        
        div.appendChild(lbl);
        div.appendChild(input);
        return div;
    }

    downloadSave() {
        if (!this.data.save) return;
        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(this.data.save, null, 4));
        const a = document.createElement('a');
        a.href = dataStr;
        a.download = "PlayerSave0.json";
        document.body.appendChild(a);
        a.click();
        a.remove();
    }

    // --- HELPERS ----

    getSelectedItem() {
        if (this.selectedRelicIndex === -1) return null;
        
        // Check if we are selecting from Stash
        if (this.selectedContainer === 'stash') {
            return this.stashItems[this.selectedRelicIndex];
        }
        
        // Otherwise, check Main Loadout
        if (this.currentLoadoutIndex !== -1 && this.data.save) {
            const loadout = this.data.save._relicLoadoutsSaveData._loadouts[this.currentLoadoutIndex];
            if (loadout && loadout.Items) {
                return loadout.Items[this.selectedRelicIndex];
            }
        }
        
        return null;
    }

    updateAffixLock(affixIndex, isLocked, isImplicit) {
        const item = this.getSelectedItem();
        if (!item) return;

        if (!isImplicit && item._affixesData && item._affixesData[affixIndex]) {
            item._affixesData[affixIndex]._locked = isLocked;
        }
    }

    addAffix(isImplicit) {
        const item = this.getSelectedItem();
        if (!item) return;
        
        // Default new affix template
        // We use ID 0 as a placeholder (user can change it via dropdown)
        const newAffix = {
            _relicAffixDefinitionId: 0, 
            _rollValue: 0.5,
            _locked: false,
            _tier: item._tier || 1
        };

        if (isImplicit) {
            if (!item._implicitAffixesData) item._implicitAffixesData = [];
            // Implicit affixes are wrapped in a container object
            item._implicitAffixesData.push({ _relicAffixData: newAffix });
        } else {
            if (!item._affixesData) item._affixesData = [];
            item._affixesData.push(newAffix);
        }
        
        this.renderInspector();
    }

    removeAffix(index, isImplicit) {
        const item = this.getSelectedItem();
        if (!item) return;

        if (isImplicit && item._implicitAffixesData) {
            item._implicitAffixesData.splice(index, 1);
        } else if (!isImplicit && item._affixesData) {
            item._affixesData.splice(index, 1);
        }
        this.renderInspector();
    }

    extractName(def) {
        if (Array.isArray(def.nameLocalizationKey)) {
            const en = def.nameLocalizationKey.find(k => k.langCode === 'en');
            return en ? en.langTranslation : def.nameLocalizationKey[0].langTranslation;
        }
        return def.name;
    }

    formatString(str) {
        if (!str) return '';
        return str.replace(/([A-Z])/g, ' $1') // 1. Add space before capitals
                  .replace(/\s+/g, ' ')       // 2. Collapse multiple spaces into one
                  .trim();                    // 3. Remove leading/trailing spaces
    }

    getAffixName(affixId) {
        const def = this.definitions.affixes[affixId];
        if (!def) return `ID: ${affixId}`;
        
        // Priority 1: name (formatted)
        if (def.name) {
            return this.formatString(def.name);
        }

        // Priority 2: eStatDefinition (formatted)
        if (def.eStatDefinition) {
            return this.formatString(def.eStatDefinition);
        }

        // Priority 3: fallback to localization
        if (Array.isArray(def.nameLocalizationKey)) {
            const en = def.nameLocalizationKey.find(k => k.langCode === 'en');
            return en ? en.langTranslation : def.nameLocalizationKey[0].langTranslation;
        }
        
        return `ID: ${affixId}`;
    }

    getAffixRange(affixId, tier) {
        const def = this.definitions.affixes[affixId];
        if (!def || !def.tierRollRanges) return null;
        
        const tierData = def.tierRollRanges.find(t => t.tier === tier);
        return tierData ? tierData.rollRange : null; 
    }

    getUpgradeMultiplier(level, affixDef) {
        let mods = null;

        // 1. Check for Affix-Specific Config (The "Multiplicative" override)
        if (affixDef && affixDef.relicUpgradeModifierConfig && affixDef.relicUpgradeModifierConfig.upgradeModifier) {
            mods = affixDef.relicUpgradeModifierConfig.upgradeModifier;
        }
        // 2. Check for Global Default (Loaded from file)
        else if (this.definitions.defaultUpgradeModifiers) {
            mods = this.definitions.defaultUpgradeModifiers;
        }
        // 3. Fallback to Hardcoded Standard
        else {
            mods = this.definitions.fallbackUpgradeModifiers;
        }

        if (mods) {
            const val = mods[String(level)];
            return val !== undefined ? parseFloat(val) : 1.0;
        }
        return 1.0;
    }

    getAdditiveOverrideConfig(affixDef) {
        if (!affixDef) return null;
        // Check 1: Root property
        if (affixDef.upgradeModifierOverride) return affixDef.upgradeModifierOverride;
        // Check 2: Nested inside modifier config
        if (affixDef.relicUpgradeModifierConfig && affixDef.relicUpgradeModifierConfig.upgradeModifierOverride) {
            return affixDef.relicUpgradeModifierConfig.upgradeModifierOverride;
        }
        return null;
    }

    getImplicitCategoryName(catId) {
        switch(catId) {
            case 0: return "Fury";       
            case 1: return "Faith";      
            case 2: return "Discipline";
            case 3: return "Corrupted";
            default: return "None";
        }
    }

    getRelicSize(relicDef) {
        if (!relicDef) return this.definitions.sizes.Default;
        return this.definitions.sizes[relicDef.eRelicSize] || this.definitions.sizes.Default;
    }

    startCopy(e, originalItem) {
        // 1. Deep Clone the Item Data
        const clone = JSON.parse(JSON.stringify(originalItem));
        
        // 2. Create a Visual Element for the Clone
        const def = this.definitions.relics[clone._relicBaseDefinitionID];
        const size = this.getRelicSize(def);
        
        const el = document.createElement('div');
        el.className = `relic-item rarity-${clone._eRelicRarity} dragging`;
        el.innerHTML = `<strong>${def ? this.extractName(def) : 'Copy'}</strong>`;
        
        // Size it correctly (use Main Grid size by default for visuals)
        const currentCellSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--grid-cell-size'));
        const gap = 4;
        el.style.width = `${size.w * currentCellSize + (size.w - 1) * gap}px`;
        el.style.height = `${size.h * currentCellSize + (size.h - 1) * gap}px`;
        
        // 3. Position at Mouse
        el.style.position = 'fixed';
        el.style.zIndex = 9999;
        // Center the item on the cursor
        el.style.left = `${e.clientX - (parseInt(el.style.width)/2)}px`; 
        el.style.top = `${e.clientY - (parseInt(el.style.height)/2)}px`;
        el.style.pointerEvents = 'none';

        document.body.appendChild(el);

        // 4. Force Start Drag
        // We pass 'copy_mode' as the source so attemptDrop knows not to delete the original
        this.initDrag(e, clone, -1, el, 'copy_mode');
        
        // Manually set isDragging to true since we skipped the threshold check
        this.isDragging = true;
        
        // Manually set offsets so it centers on mouse
        const rect = el.getBoundingClientRect();
        this.dragOffsetX = e.clientX - rect.left;
        this.dragOffsetY = e.clientY - rect.top;
    }

}

const app = new RelicEditor();
</script>
</body>
</html>